一.运算符重载
   1.1 是函数的特殊表现形式。
   1.2 目的
       为了方便编程
       代码更加直观
   1.3 设计一个类  叫分数类
       特征:
           分子
           分母
       功能:
           显示分数
           运算:
               +   
               -
               *
               /
       全局区定义一个函数 代表两个分数相加      
               
   1.4 Fraction   fa;
       Fraction   fb;
       fa+fb;   --->fa.operator+(const Fraction& fb)
       首先去类的成员函数中 找一个成员函数
           operator+(const Fraction& fb)
       找不到则去全局区找一个全局函数
           operator+(const Fraction& fa,
               const Fraction& fb);                         
       fa*=fb;
       fa=fa*fb; 
   1.5 设计一个整数包装类 
       int  x;
       对有成员  可以提供公开的访问接口 达到访问的目的
       使用友元函数
           友元函数的本质就是全局函数 但友元函数获得
           了对类私有成员的访问权利。
       
       对类的私有成员的访问
       受类型作用域 和 权限限制
       需要通过对象去访问
           成员函数具有以上三个特性
           静态函数具有以上二个特性
           友元函数只有第一个特性   
   1.6 两个特殊的运算符
       <<
       >> 
       Integer  ia;
       cout << ia << endl;   
       cout ------ ostream& 
       流类型的对象 不能拷贝  不能加const修饰
       先去 ostream 类型中 找一个成员函数 叫
           operator<<(const Integer& i)
       找不到 则去全局区找一个全局函数
           operator<<(ostream& os,const Integer& i);
   1.7 其它的二元运算符
       +  - *  /  
       += -=  /= *=
       <<    >>
       == (以什么标准判断两个对象是否相等?)
           int   x=10;
           int   y=10;
                    
二. 一元运算符
   2.1  一元运算符
      -  ！  ~   ++  --
    #a   首先去a对象对应的类型中 找一个成员函数
    operator#()  
    找不到  就去全局找一个全局函数叫
    operator#(a)               
   
    a#   首先去a对象对应的类型中  找一个成员函数
    operator#(int)
    找不到 就去全局找一个全局函数叫
    operator#(a,int)
    
    
三.运算符重载的限制
   3.1 不能重载的运算符
		 ::  作用域 运算符
		 .    成员运算符
		 .*   成员指针解引用
		 sizeof  计算类型大小的
		 ？ ：  三元运算符
		 typeid  获取类型信息（typeinfo）
	3.2 只能对已有的运算符 重载  不能发明 新的运算符 
	3.3 不能对基本类型 进行运算符 重载
		运算符重载中  至少有一个类型 是非基本类型
	3.4 不能改变运算符 的运算特性。
		不能把一元改成 二元
	3.5 只能是重载成 成员形式的运算符号
		=（最好是成员的 += -= /= ^=）
		[]
		()
		*  ->		
四、只能是成员的运算符重载  举例
	4.1 自定义数组  Array
		（= []）
                           
        
                         